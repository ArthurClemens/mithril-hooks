{"version":3,"file":"mithril-hooks.umd.js","sources":["../../../node_modules/flatted/esm/index.js","../src/MithrilHooks.ts"],"sourcesContent":["/*! (c) 2020 Andrea Giammarchi */\n\nconst {parse: $parse, stringify: $stringify} = JSON;\nconst {keys} = Object;\n\nconst Primitive = String;   // it could be Number\nconst primitive = 'string'; // it could be 'number'\n\nconst ignore = {};\nconst object = 'object';\n\nconst noop = (_, value) => value;\n\nconst primitives = value => (\n  value instanceof Primitive ? Primitive(value) : value\n);\n\nconst Primitives = (_, value) => (\n  typeof value === primitive ? new Primitive(value) : value\n);\n\nconst revive = (input, parsed, output, $) => {\n  const lazy = [];\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\n    const k = ke[y];\n    const value = output[k];\n    if (value instanceof Primitive) {\n      const tmp = input[value];\n      if (typeof tmp === object && !parsed.has(tmp)) {\n        parsed.add(tmp);\n        output[k] = ignore;\n        lazy.push({k, a: [input, parsed, tmp, $]});\n      }\n      else\n        output[k] = $.call(output, k, tmp);\n    }\n    else if (output[k] !== ignore)\n      output[k] = $.call(output, k, value);\n  }\n  for (let {length} = lazy, i = 0; i < length; i++) {\n    const {k, a} = lazy[i];\n    output[k] = $.call(output, k, revive.apply(null, a));\n  }\n  return output;\n};\n\nconst set = (known, input, value) => {\n  const index = Primitive(input.push(value) - 1);\n  known.set(value, index);\n  return index;\n};\n\nexport const parse = (text, reviver) => {\n  const input = $parse(text, Primitives).map(primitives);\n  const value = input[0];\n  const $ = reviver || noop;\n  const tmp = typeof value === object && value ?\n              revive(input, new Set, value, $) :\n              value;\n  return $.call({'': tmp}, '', tmp);\n};\n\nexport const stringify = (value, replacer, space) => {\n  const $ = replacer && typeof replacer === object ?\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\n            (replacer || noop);\n  const known = new Map;\n  const input = [];\n  const output = [];\n  let i = +set(known, input, $.call({'': value}, '', value));\n  let firstRun = !i;\n  while (i < input.length) {\n    firstRun = true;\n    output[i] = $stringify(input[i++], replace, space);\n  }\n  return '[' + output.join(',') + ']';\n  function replace(key, value) {\n    if (firstRun) {\n      firstRun = !firstRun;\n      return value;\n    }\n    const after = $.call(this, key, value);\n    switch (typeof after) {\n      case object:\n        if (after === null) return after;\n      case primitive:\n        return known.get(after) || set(known, input, after);\n    }\n    return after;\n  }\n};\n\nexport const toJSON = any => $parse(stringify(any));\nexport const fromJSON = any => parse($stringify(any));\n","import { stringify } from 'flatted';\nimport m, { Children, Component, Vnode, VnodeDOM } from 'mithril';\n\nimport type { MithrilHooks, ReactTypes } from './types';\n\nlet currentState: MithrilHooks.State;\n\nconst call = Function.prototype.call.bind(Function.prototype.call);\n\nconst scheduleRender = () =>\n  // Call m within the function body so environments with a global instance of m (like flems.io) don't complain\n  m.redraw();\n\nconst updateDeps = (deps?: ReactTypes.DependencyList) => {\n  const state = currentState;\n  const { depsIndex } = state;\n  state.depsIndex += 1;\n  const prevDeps = state.depsStates[depsIndex] || [];\n  const shouldRecompute =\n    deps === undefined\n      ? true // Always compute\n      : Array.isArray(deps)\n      ? deps.length > 0\n        ? !deps.every((x, i) => x === prevDeps[i]) // Only compute when one of the deps has changed\n        : !state.setup // Empty array: only compute at mount\n      : false; // Invalid value, do nothing\n  if (deps !== undefined) {\n    state.depsStates[depsIndex] = deps;\n  }\n  return shouldRecompute;\n};\n\nconst effect =\n  (isAsync = false) =>\n  (fn: ReactTypes.EffectCallback, deps?: ReactTypes.DependencyList) => {\n    const state = currentState;\n    const shouldRecompute = updateDeps(deps);\n    if (shouldRecompute) {\n      const { depsIndex } = state;\n      const runCallbackFn = () => {\n        const teardown = fn();\n        // A callback may return a function. If any, add it to the teardowns:\n        if (typeof teardown === 'function') {\n          // Store this this function to be called at cleanup and unmount\n          state.teardowns.set(\n            depsIndex,\n            teardown as MithrilHooks.EffectReturnFn,\n          );\n          // At unmount, call re-render at least once\n          state.teardowns.set('_', scheduleRender);\n        }\n      };\n\n      // First clean up any previous cleanup function\n      const teardown = state.teardowns.get(depsIndex);\n      try {\n        if (typeof teardown === 'function') {\n          teardown();\n        }\n      } finally {\n        state.teardowns.delete(depsIndex);\n      }\n\n      state.updates.push(\n        isAsync\n          ? () =>\n              new Promise(resolve => {\n                requestAnimationFrame(resolve);\n              }).then(runCallbackFn)\n          : runCallbackFn,\n      );\n    }\n  };\n\nconst updateState = <T>(\n  initialState?: T,\n  newValueFn?: MithrilHooks.NewValueFn<T>,\n): [T, (value: MithrilHooks.ValueOrFn<T>) => any, number] => {\n  const state = currentState;\n  const index = state.statesIndex;\n  state.statesIndex += 1;\n  if (!state.setup) {\n    state.states[index] = initialState;\n  }\n  return [\n    state.states[index] as T,\n    (value: MithrilHooks.ValueOrFn<T>) => {\n      const previousValue = state.states[index];\n      const newValue = newValueFn ? newValueFn(value as T, index) : value;\n      state.states[index] = newValue;\n      if (stringify(newValue) !== stringify(previousValue)) {\n        scheduleRender(); // Calling redraw multiple times: Mithril will drop extraneous redraw calls, so performance should not be an issue\n      }\n    },\n    index,\n  ];\n};\n\nexport const useState = <T = unknown>(\n  initialState?: T,\n): [T, (value: MithrilHooks.ValueOrFn<T>) => unknown, number] => {\n  const state = currentState;\n  const newValueFn = (value: MithrilHooks.ValueOrFn<T>, index: number) =>\n    typeof value === 'function'\n      ? (value as MithrilHooks.ValueFn<T>)(state.states[index] as T, index)\n      : value;\n  return updateState<T>(initialState, newValueFn);\n};\n\nexport const useEffect = effect(true);\nexport const useLayoutEffect = effect();\n\nexport function useReducer<T, A = any, U = any>(\n  reducer: MithrilHooks.Reducer<T, A>,\n  initialState: U,\n  initFn: (args?: U) => T,\n): [T, (action: A) => T];\nexport function useReducer<T, A = any, U = any>(\n  reducer: MithrilHooks.Reducer<T, A>,\n  initialState?: T,\n  initFn?: never,\n): [T, (action: A) => T];\nexport function useReducer<T, A = any, U = any>(\n  reducer: MithrilHooks.Reducer<T, A>,\n  initialState?: unknown,\n  initFn?: ((args?: unknown) => T) | never,\n): [T, (action: A) => T] {\n  const state = currentState;\n  // From the React docs: You can also create the initial state lazily. To do this, you can pass an init function as the third argument. The initial state will be set to init(initialValue).\n  const initValue: T =\n    !state.setup && initFn\n      ? (initFn(initialState as U) as T)\n      : (initialState as T);\n\n  const getValueDispatch = (): [T, (action: A) => T] => {\n    const [value, setValue, index] = updateState(initValue);\n    const dispatch = (action: A): T => {\n      const previousValue = state.states[index] as T;\n      return setValue(\n        // Next state:\n        reducer(previousValue, action),\n      );\n    };\n    return [value, dispatch];\n  };\n\n  return getValueDispatch();\n}\n\nexport const useRef = <T = unknown>(initialValue?: T) => {\n  // A ref is a persisted object that will not be updated, so it has no setter\n  const [value] = updateState<{ current: T | undefined }>({\n    current: initialValue,\n  });\n  return value;\n};\n\nexport const useMemo = <T = unknown>(\n  fn: MithrilHooks.MemoFn<T>,\n  deps?: ReactTypes.DependencyList,\n) => {\n  const state = currentState;\n  const shouldRecompute = updateDeps(deps);\n  const [memoized, setMemoized] = !state.setup\n    ? updateState<T>(fn())\n    : updateState<T>();\n  if (state.setup && shouldRecompute) {\n    setMemoized(fn());\n  }\n  return memoized;\n};\n\nexport const useCallback = <T extends (...args: unknown[]) => unknown>(\n  callback: T,\n  deps?: ReactTypes.DependencyList,\n) =>\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useMemo(() => callback, deps);\n\nexport const withHooks = <T = unknown>(\n  renderFunction: (\n    attrs: T & { vnode: Vnode<T, MithrilHooks.State>; children: Children },\n  ) => Children,\n  initialAttrs?: T,\n): Component<T, MithrilHooks.State> => {\n  const init = (vnode: Vnode<T, MithrilHooks.State>) => {\n    Object.assign(vnode.state, {\n      setup: false,\n      states: [],\n      statesIndex: 0,\n      depsStates: [],\n      depsIndex: 0,\n      updates: [],\n      cleanups: new Map(),\n      teardowns: new Map(), // Keep track of teardowns even when the update was run only once\n    });\n  };\n\n  const update = (vnode: VnodeDOM<T, MithrilHooks.State>) => {\n    const prevState = currentState;\n    currentState = vnode.state;\n    try {\n      vnode.state.updates.forEach(call);\n    } finally {\n      Object.assign(vnode.state, {\n        setup: true,\n        updates: [],\n        depsIndex: 0,\n        statesIndex: 0,\n      });\n      currentState = prevState;\n    }\n  };\n\n  // eslint-disable-next-line consistent-return\n  const render = (vnode: Vnode<T, MithrilHooks.State>) => {\n    const prevState = currentState;\n    currentState = vnode.state;\n    try {\n      return renderFunction({\n        ...initialAttrs,\n        ...vnode.attrs,\n        vnode,\n        children: vnode.children,\n      });\n    } catch (e) {\n      console.error(e); // eslint-disable-line no-console\n    } finally {\n      currentState = prevState;\n    }\n    return undefined;\n  };\n\n  const teardown = (vnode: VnodeDOM<T, MithrilHooks.State>) => {\n    const prevState = currentState;\n    currentState = vnode.state;\n    try {\n      vnode.state.teardowns.forEach(call);\n    } finally {\n      currentState = prevState;\n    }\n  };\n\n  return {\n    oninit: init,\n    oncreate: update,\n    onupdate: update,\n    view: render,\n    onremove: teardown,\n  };\n};\n"],"names":["value","teardown"],"mappings":"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","x_google_ignoreList":[0]}